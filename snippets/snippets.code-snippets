{
    "description": "Stand API for VS Code",

    // MENU snippets
    "menu.my_root": {
        "prefix": ["menu.my_root"],
        "body": [
          "menu.my_root()"
        ],
        "description": "Returns a reference to the list that your script gets when it is started."
      },
    "menu.player_root": {
        "prefix": ["menu.player_root"],
        "body": [
          "player_root(int player_id);"
        ],
        "description": "Returns a reference to the list that the given player owns. Note that the returned reference may be invalid even if called in an on_join handler."
    },
    "menu.shadow_root": {
        "prefix": ["menu.shadow_root"],
        "body": [
          "menu.shadow_root()"
        ],
        "description": "Using return value of this function to create a command produces a detached command (CommandUniqPtr) instead of a CommandRef."
    },
      
    "menu.ref_by_path": {
        "prefix": ["menu.ref_by_path"],
        "body": [
          "menu.ref_by_path(path, tree_version)"
        ],
        "description": "Returns a reference to any command in Stand using a path such as Self>Immortality. Note that the path has to be in English (UK) and using the no-space greater-than separator. Providing a tree version is optional but highly recommended for future-proofing. You can find this in any tree config file, such as your profile."
    },
      
    "menu.ref_by_rel_path": {
        "prefix": ["menu.ref_by_rel_path"],
        "body": [
          "menu.ref_by_rel_path(base, path)"
        ],
        "description": null
    },
      
    "menu.ref_by_command_name": {
        "prefix": ["menu.ref_by_command_name"],
        "body": [
          "menu.ref_by_command_name(command_name)"
        ],
        "description": null
    },
      
    "menu.list": {
        "prefix": ["menu.list"],
        "body": [
          "menu.list(parent, menu_name, command_names, help_text, on_click, on_back, on_active_list_update)"
        ],
        "description": null
    },
      
    "menu.action": {
        "prefix": ["menu.action"],
        "body": [
          "menu.action(parent, menu_name, command_names, help_text, on_click, on_command, syntax, perm)"
        ],
        "description": null
    },
    "menu.toggle": {
        "prefix": ["menu.toggle"],
        "body": [
          "menu.toggle(parent, menu_name, command_names, help_text, on_change, default_on = false)"
        ],
        "description": "Toggle menu item."
    },
      
    "menu.toggle_loop": {
        "prefix": ["menu.toggle_loop"],
        "body": [
          "menu.toggle_loop(parent, menu_name, command_names, help_text, on_tick, on_stop = nil)"
        ],
        "description": "Toggle menu item with continuous loop."
    },
      
    "menu.slider": {
        "prefix": ["menu.slider"],
        "body": [
          "menu.slider(parent, menu_name, command_names, help_text, min_value, max_value, default_value, step_size, on_change)"
        ],
        "description": "Slider menu item (integer values)."
    },
      
    "menu.slider_float": {
        "prefix": ["menu.slider_float"],
        "body": [
          "menu.slider_float(parent, menu_name, command_names, help_text, min_value, max_value, default_value, step_size, on_change)"
        ],
        "description": "Slider menu item (float values)."
    },
      
    "menu.click_slider": {
        "prefix": ["menu.click_slider"],
        "body": [
          "menu.click_slider(parent, menu_name, command_names, help_text, min_value, max_value, default_value, step_size, on_click)"
        ],
        "description": "Clickable slider menu item (integer values)."
    },
      
    "menu.click_slider_float": {
        "prefix": ["menu.click_slider_float"],
        "body": [
          "menu.click_slider_float(parent, menu_name, command_names, help_text, min_value, max_value, default_value, step_size, on_click)"
        ],
        "description": "Clickable slider menu item (float values)."
    },
      
    "menu.list_select": {
        "prefix": ["menu.list_select"],
        "body": [
          "menu.list_select(parent, menu_name, command_names, help_text, options, default_value, on_change)"
        ],
        "description": "List selection menu item."
    },
    "menu.list_action": {
        "prefix": ["menu.list_action"],
        "body": [
          "menu.list_action(parent, menu_name, command_names, help_text, options, on_item_click)"
        ],
        "description": "List action menu item. Options must be a table of list action item data. List action item data is an index-based table that contains value, menu_name, command_names, help_text, and category. Value and menu_name are mandatory. Your on_item_click function will be called when a list item is clicked."
    },
    "menu.text_input": {
        "prefix": ["menu.text_input"],
        "body": [
          "menu.text_input(parent, menu_name, command_names, help_text, on_change, default_value = \"\")"
        ],
        "description": "Text input menu item. Your on_change function will be called with the string and click type."
    },
      
    "menu.colour": {
        "prefix": ["menu.colour"],
        "body": [
          "menu.colour(parent, menu_name, command_names, help_text, default, transparency, on_change)",
          // OR
          "menu.colour(parent, menu_name, command_names, help_text, default_r, default_g, default_b, default_a, transparency, on_change)"
        ],
        "description": "Colour picker menu item. Your on_change function will be called with the selected colour and click type. Default can be either a Colour type or individual RGBA components."
    },
    "menu.rainbow": {
        "prefix": ["menu.rainbow"],
        "body": [
          "menu.rainbow(colour_command)"
        ],
        "description": "Creates a rainbow slider for the given colour command. This should be called right after creating the colour command."
    },
      
    "menu.inline_rainbow": {
        "prefix": ["menu.inline_rainbow"],
        "body": [
          "menu.inline_rainbow(colour_command)"
        ],
        "description": "Creates a rainbow slider inside the given colour command. This should be called right after creating the colour command."
    },
      
    "menu.divider": {
        "prefix": ["menu.divider"],
        "body": [
          "menu.divider(parent, menu_name)"
        ],
        "description": "Creates a divider menu item."
    },
      
    "menu.readonly": {
        "prefix": ["menu.readonly"],
        "body": [
          "menu.readonly(parent, menu_name, value = \"\")"
        ],
        "description": "Creates a readonly menu item. Pairs well with menu.on_tick_in_viewport and menu.set_value."
    },
      
    "menu.hyperlink": {
        "prefix": ["menu.hyperlink"],
        "body": [
          "menu.hyperlink(parent, menu_name, link, help_text = \"\")"
        ],
        "description": "Creates a hyperlink menu item."
    },
      
    "menu.textslider": {
        "prefix": ["menu.textslider"],
        "body": [
          "menu.textslider(parent, menu_name, command_names, help_text, options, on_click)"
        ],
        "description": "Creates a textslider menu item. Use menu.list_action instead, unless options are really unimportant. Your on_click function will be called with the option's index, value, and click_type as parameters."
    },
      
    "menu.textslider_stateful": {
        "prefix": ["menu.textslider_stateful"],
        "body": [
          "menu.textslider_stateful(parent, menu_name, command_names, help_text, options, on_click)"
        ],
        "description": "Creates a stateful textslider menu item. Use menu.list_select instead, unless options are really unimportant. Your on_click function will be called with the option's index, value, and click_type as parameters."
    },
      
    "menu.player_list_players_shortcut": {
        "prefix": ["menu.player_list_players_shortcut"],
        "body": [
          "menu.player_list_players_shortcut(parent, menu_name, command_name, single_only = false)"
        ],
        "description": "Creates a player list with shortcut menu item."
    },
      
    "menu.link": {
        "prefix": ["menu.link"],
        "body": [
          "menu.link(parent, target, show_address_in_corner = false)"
        ],
        "description": "Creates a link menu item."
    },
      
    "menu.apply_command_states": {
        "prefix": ["menu.apply_command_states"],
        "body": [
          "menu.apply_command_states()"
        ],
        "description": "Loads state & hotkeys for commands you've created without needing to yield. Note that your script is always expected to create all (stateful) commands within the first 100 ticks."
    },
      
    "menu.delete": {
        "prefix": ["menu.delete"],
        "body": [
          "menu.delete(command)"
        ],
        "description": "Deletes the specified command."
    },
      
    "menu.replace": {
        "prefix": ["menu.replace"],
        "body": [
          "menu.replace(old, new)"
        ],
        "description": "Replaces the specified old command with a new command."
    },
      
    "menu.detach": {
        "prefix": ["menu.detach"],
        "body": [
          "menu.detach(command)"
        ],
        "description": "Detaches the specified command."
    },
      
    "menu.attach": {
        "prefix": ["menu.attach"],
        "body": [
          "menu.attach(parent, command)"
        ],
        "description": "Attaches the specified command to the given parent."
    },
      
    "menu.attach_after": {
        "prefix": ["menu.attach_after"],
        "body": [
          "menu.attach_after(anchor, command)"
        ],
        "description": "Attaches the specified command after the given anchor."
    },
      
    "menu.attach_before": {
        "prefix": ["menu.attach_before"],
        "body": [
          "menu.attach_before(anchor, command)"
        ],
        "description": "Attaches the specified command before the given anchor."
    },
      
    "menu.is_ref_valid": {
        "prefix": ["menu.is_ref_valid"],
        "body": [
          "menu.is_ref_valid(ref)"
        ],
        "description": "Returns whether the referenced command still exists."
    },
      
    "menu.focus": {
        "prefix": ["menu.focus"],
        "body": [
          "menu.focus(command)"
        ],
        "description": "Focuses on the specified command."
    },
      
    "menu.is_focused": {
        "prefix": ["menu.is_focused"],
        "body": [
          "menu.is_focused(command)"
        ],
        "description": "Returns whether the specified command is currently focused."
    },
      
    "menu.get_applicable_players": {
      "prefix": ["menu.get_applicable_players"],
      "body": [
        "menu.get_applicable_players(command, include_user = nil)"
      ],
      "description": "Gets the applicable players for the specified command."
    },
    
    "menu.get_parent": {
        "prefix": ["menu.get_parent"],
        "body": [
          "menu.get_parent(command)"
        ],
        "description": "Gets the parent command of the specified command."
    },  

    "menu.get_type": {
        "prefix": ["menu.get_type"],
        "body": [
          "menu.get_type(command)"
        ],
        "description": "Gets the type of the specified command. The type may equal one of the predefined values like COMMAND_LINK, COMMAND_ACTION, etc."
    },  

    "menu.get_children": {
        "prefix": ["menu.get_children"],
        "body": [
          "menu.get_children(list)"
        ],
        "description": "Gets the children commands of the specified list command."
    },  

    "menu.list_get_focus": {
        "prefix": ["menu.list_get_focus"],
        "body": [
          "menu.list_get_focus(list)"
        ],
        "description": "Gets the focus of the specified list command."
    },  

    "menu.list_get_focus_physical": {
        "prefix": ["menu.list_get_focus_physical"],
        "body": [
          "menu.list_get_focus_physical(list)"
        ],
        "description": "Gets the physical focus of the specified list command."
    },  

    "menu.collect_garbage": {
        "prefix": ["menu.collect_garbage"],
        "body": [
          "menu.collect_garbage()"
        ],
        "description": "Removes invalidated weakrefs from an internal vector. Stand does this automatically, but if you bulk-delete-or-replace commands, you might want to call this right after."
    },
    "menu.is_open": {
          "prefix": ["menu.is_open"],
          "body": [
            "menu.is_open()"
          ],
          "description": "Returns true if the menu is open, otherwise false."
    },  

    "menu.get_position": {
        "prefix": ["menu.get_position"],
        "body": [
          "menu.get_position()"
        ],
        "description": "Returns the menu grid origin x & y as two values."
    },  

    "menu.get_main_view_position_and_size": {
        "prefix": ["menu.get_main_view_position_and_size"],
        "body": [
          "menu.get_main_view_position_and_size()"
        ],
        "description": "Returns x, y, width, & height for the current main view (active list, warning, etc.)."
    },  

    "menu.get_current_menu_list": {
        "prefix": ["menu.get_current_menu_list"],
        "body": [
          "menu.get_current_menu_list()"
        ],
        "description": "Returns a reference to the current menu list, which ignores the context menu."
    },  

    "menu.get_current_ui_list": {
        "prefix": ["menu.get_current_ui_list"],
        "body": [
          "menu.get_current_ui_list()"
        ],
        "description": "Returns a reference to the current UI list, which can include the context menu."
    },  

    "menu.get_active_list_cursor_text": {
        "prefix": ["menu.get_active_list_cursor_text"],
        "body": [
          "menu.get_active_list_cursor_text(even_when_disabled = false, even_when_inappropriate = false)"
        ],
        "description": "Returns the cursor text of the current UI list."
    },  

    "menu.are_tabs_visible": {
        "prefix": ["menu.are_tabs_visible"],
        "body": [
          "menu.are_tabs_visible()"
        ],
        "description": "Returns true if tabs are visible, otherwise false."
    },  

    "menu.show_command_box": {
        "prefix": ["menu.show_command_box"],
        "body": [
          "menu.show_command_box(prefill)"
        ],
        "description": "Opens the command box with the specified prefill text."
    },  

    "menu.show_command_box_click_based": {
        "prefix": ["menu.show_command_box_click_based"],
        "body": [
          "menu.show_command_box_click_based(click_type, prefill)"
        ],
        "description": "Opens the command box with the specified prefill text based on the click type."
    },  

    "menu.trigger_commands": {
        "prefix": ["menu.trigger_commands"],
        "body": [
          "menu.trigger_commands(input)"
        ],
        "description": "Triggers the specified commands using the provided input."
    },  

    "menu.trigger_command": {
        "prefix": ["menu.trigger_command"],
        "body": [
          "menu.trigger_command(command, arg)"
        ],
        "description": "Triggers the specified command with the given argument."
    },  

    "menu.command_box_is_open": {
        "prefix": ["menu.command_box_is_open"],
        "body": [
          "menu.command_box_is_open()"
        ],
        "description": "Returns true if the command box is open, otherwise false."
    },  

    "menu.command_box_get_dimensions": {
        "prefix": ["menu.command_box_get_dimensions"],
        "body": [
          "menu.command_box_get_dimensions()"
        ],
        "description": "Returns x, y, width, & height of the command box."
    },  

    "menu.is_in_screenshot_mode": {
        "prefix": ["menu.is_in_screenshot_mode"],
        "body": [
          "menu.is_in_screenshot_mode()"
        ],
        "description": "Returns true if the menu is in screenshot mode, otherwise false."
    },
    //Players Functions
    "players.add_command_hook": {
        "prefix": ["players.add_command_hook"],
        "body": [
          "players.add_command_hook(callback)"
        ],
        "description": "Registers a function to be called when a player should have script features added. Your callback will be called with the player id and player root as arguments."
      },
      
      "players.on_join": {
        "prefix": ["players.on_join"],
        "body": [
          "players.on_join(callback)"
        ],
        "description": "Registers a function to be called when a player joins the session. Your callback will be called with the player id as an argument."
      },
      
      "players.on_leave": {
        "prefix": ["players.on_leave"],
        "body": [
          "players.on_leave(callback)"
        ],
        "description": "Registers a function to be called when a player leaves the session. Your callback will be called with the player id and name as arguments."
      },
      
      "players.dispatch_on_join": {
        "prefix": ["players.dispatch_on_join"],
        "body": [
          "players.dispatch_on_join()"
        ],
        "description": "Calls your join handler(s) for every player that is already in the session."
      },
      
      "players.exists": {
        "prefix": ["players.exists"],
        "body": [
          "players.exists(player_id)"
        ],
        "description": "Checks if a player with the given id is in session."
      },
      
      "players.user": {
        "prefix": ["players.user"],
        "body": [
          "players.user()"
        ],
        "description": "Alternative to the PLAYER.PLAYER_ID native."
      },
      
      "players.user_ped": {
        "prefix": ["players.user_ped"],
        "body": [
          "players.user_ped()"
        ],
        "description": "Alternative to the PLAYER.PLAYER_PED_ID native."
      },
      
      "players.list": {
        "prefix": ["players.list"],
        "body": [
          "players.list(include_user = true, include_friends = true, include_strangers = true)"
        ],
        "description": "Returns an index-based table with all matching player ids."
      },
      
      "players.list_only": {
        "prefix": ["players.list_only"],
        "body": [
          "players.list_only(include_user = false, include_friends = false, include_crew_members = false, include_org_members = false)"
        ],
        "description": "Returns an index-based table with all matching player ids."
      },
      
      "players.list_except": {
        "prefix": ["players.list_except"],
        "body": [
          "players.list_except(exclude_user = false, exclude_friends = false, exclude_crew_members = false, exclude_org_members = false)"
        ],
        "description": "Returns an index-based table with all matching player ids."
      },
      
      "players.get_host": {
        "prefix": ["players.get_host"],
        "body": [
          "players.get_host()"
        ],
        "description": "Returns the host player id."
      },
      
      "players.get_script_host": {
        "prefix": ["players.get_script_host"],
        "body": [
          "players.get_script_host()"
        ],
        "description": "Returns the script host player id."
      },
      
      "players.get_focused": {
        "prefix": ["players.get_focused"],
        "body": [
          "players.get_focused()"
        ],
        "description": "Returns an index-based table containing the ids of all players focused in the menu."
      },
      
      "players.get_name": {
        "prefix": ["players.get_name"],
        "body": [
          "players.get_name(player_id)"
        ],
        "description": "Returns the name of the player with the given id."
      },
      "players.get_rockstar_id": {
        "prefix": ["players.get_rockstar_id"],
        "body": [
          "players.get_rockstar_id(player_id)"
        ],
        "description": "Returns the Rockstar Social Club ID of the player with the given ID. Returns 4294967295 if unknown."
      },
      
      "players.get_ip": {
        "prefix": ["players.get_ip"],
        "body": [
          "players.get_ip(player_id)"
        ],
        "description": "Returns the IP address of the player with the given ID. Returns 4294967295 if unknown."
      },
      
      "players.get_port": {
        "prefix": ["players.get_port"],
        "body": [
          "players.get_port(player_id)"
        ],
        "description": "Returns the port number of the player with the given ID. Returns 0 if unknown."
      },
      
      "players.get_connect_ip": {
        "prefix": ["players.get_connect_ip"],
        "body": [
          "players.get_connect_ip(player_id)"
        ],
        "description": "Returns the connecting IP address of the player with the given ID. Returns 4294967295 if the player is not connected via P2P."
      },
      
      "players.get_connect_port": {
        "prefix": ["players.get_connect_port"],
        "body": [
          "players.get_connect_port(player_id)"
        ],
        "description": "Returns the connecting port number of the player with the given ID. Returns 0 if the player is not connected via P2P."
      },
      
      "players.get_lan_ip": {
        "prefix": ["players.get_lan_ip"],
        "body": [
          "players.get_lan_ip(player_id)"
        ],
        "description": "Returns the LAN IP address of the player with the given ID. Returns 4294967295 if unknown."
      },
      
      "players.get_lan_port": {
        "prefix": ["players.get_lan_port"],
        "body": [
          "players.get_lan_port(player_id)"
        ],
        "description": "Returns the LAN port number of the player with the given ID. Returns 0 if unknown."
      },
      
      "players.are_stats_ready": {
        "prefix": ["players.are_stats_ready"],
        "body": [
          "players.are_stats_ready(player_id)"
        ],
        "description": "Checks if the stats of the player with the given ID are ready."
      },
      
      "players.get_rank": {
        "prefix": ["players.get_rank"],
        "body": [
          "players.get_rank(player_id)"
        ],
        "description": "Returns the rank of the player with the given ID."
      },
      
      "players.get_rp": {
        "prefix": ["players.get_rp"],
        "body": [
          "players.get_rp(player_id)"
        ],
        "description": "Returns the RP (Reputation Points) of the player with the given ID."
      },
      
      "players.get_money": {
        "prefix": ["players.get_money"],
        "body": [
          "players.get_money(player_id)"
        ],
        "description": "Returns the in-game money of the player with the given ID."
      },
      
      "players.get_wallet": {
        "prefix": ["players.get_wallet"],
        "body": [
          "players.get_wallet(player_id)"
        ],
        "description": "Returns the amount of money in the wallet of the player with the given ID."
      },
      
      "players.get_bank": {
        "prefix": ["players.get_bank"],
        "body": [
          "players.get_bank(player_id)"
        ],
        "description": "Returns the amount of money in the bank of the player with the given ID."
      },
      
      "players.get_kd": {
        "prefix": ["players.get_kd"],
        "body": [
          "players.get_kd(player_id)"
        ],
        "description": "Returns the kill-to-death ratio of the player with the given ID."
      },
      
      "players.get_kills": {
        "prefix": ["players.get_kills"],
        "body": [
          "players.get_kills(player_id)"
        ],
        "description": "Returns the number of kills of the player with the given ID."
      },
      
      "players.get_deaths": {
        "prefix": ["players.get_deaths"],
        "body": [
          "players.get_deaths(player_id)"
        ],
        "description": "Returns the number of deaths of the player with the given ID."
      },
      
      "players.get_language": {
        "prefix": ["players.get_language"],
        "body": [
          "players.get_language(player_id)"
        ],
        "description": "Returns the language of the player with the given ID. Returns the same as the LOCALIZATION.GET_CURRENT_LANGUAGE native."
      },
      
      "players.is_using_controller": {
        "prefix": ["players.is_using_controller"],
        "body": [
          "players.is_using_controller(player_id)"
        ],
        "description": "Checks if the player with the given ID is using a controller."
      },
      
      "players.get_name_with_tags": {
        "prefix": ["players.get_name_with_tags"],
        "body": [
          "players.get_name_with_tags(player_id)"
        ],
        "description": "Returns the name of the player with the given ID, including tags if any."
      },
      
      "players.get_tags_string": {
        "prefix": ["players.get_tags_string"],
        "body": [
          "players.get_tags_string(player_id)"
        ],
        "description": "Returns a string representing the tags of the player with the given ID."
      },
      
      "players.is_godmode": {
        "prefix": ["players.is_godmode"],
        "body": [
          "players.is_godmode(player_id)"
        ],
        "description": "Checks if the player with the given ID is in god mode."
      },
      
      "players.is_marked_as_modder": {
        "prefix": ["players.is_marked_as_modder"],
        "body": [
          "players.is_marked_as_modder(player_id)"
        ],
        "description": "Returns true if the player with the given ID is marked as a modder."
      },
      
      "players.is_marked_as_modder_or_admin": {
        "prefix": ["players.is_marked_as_modder_or_admin"],
        "body": [
          "players.is_marked_as_modder_or_admin(player_id)"
        ],
        "description": "Returns true if the player with the given ID is marked as a modder or admin."
      },
      
      "players.is_marked_as_admin": {
        "prefix": ["players.is_marked_as_admin"],
        "body": [
          "players.is_marked_as_admin(player_id)"
        ],
        "description": "Returns true if the player with the given ID is marked as an admin."
      },
      
      "players.is_marked_as_attacker": {
        "prefix": ["players.is_marked_as_attacker"],
        "body": [
          "players.is_marked_as_attacker(player_id)"
        ],
        "description": "Checks if the player with the given ID is marked as an attacker."
      },
      
      "players.is_otr": {
        "prefix": ["players.is_otr"],
        "body": [
          "players.is_otr(player_id)"
        ],
        "description": "Checks if the player with the given ID is in 'Off the Radar' mode."
      },
      
      "players.is_out_of_sight": {
        "prefix": ["players.is_out_of_sight"],
        "body": [
          "players.is_out_of_sight(player_id)"
        ],
        "description": "Checks if the player with the given ID is out of sight."
      },
      
      "players.is_in_interior": {
        "prefix": ["players.is_in_interior"],
        "body": [
          "players.is_in_interior(player_id)"
        ],
        "description": "Checks if the player with the given ID is inside an interior."
      },
      
      "players.is_typing": {
        "prefix": ["players.is_typing"],
        "body": [
          "players.is_typing(player_id)"
        ],
        "description": "Checks if the player with the given ID is typing."
      },
      
      "players.is_using_vpn": {
        "prefix": ["players.is_using_vpn"],
        "body": [
          "players.is_using_vpn(player_id)"
        ],
        "description": "Checks if the player with the given ID is using a VPN."
      },
      
      "players.is_visible": {
        "prefix": ["players.is_visible"],
        "body": [
          "players.is_visible(player_id)"
        ],
        "description": "Checks if the player with the given ID is visible."
      },
      
      "players.get_host_token": {
        "prefix": ["players.get_host_token"],
        "body": [
          "players.get_host_token(player_id)"
        ],
        "description": "Returns the host token of the player with the given ID as a decimal string."
      },
      
      "players.get_host_token_hex": {
        "prefix": ["players.get_host_token_hex"],
        "body": [
          "players.get_host_token_hex(player_id)"
        ],
        "description": "Returns the host token of the player with the given ID as a 16-character padded hex string."
      },
      
      "players.get_host_queue_position": {
        "prefix": ["players.get_host_queue_position"],
        "body": [
          "players.get_host_queue_position(player_id)"
        ],
        "description": "Returns the position in the host queue of the player with the given ID or 0 if not applicable."
      },
      
      "players.get_host_queue": {
        "prefix": ["players.get_host_queue"],
        "body": [
          "players.get_host_queue(include_user = true, include_friends = true, include_strangers = true)"
        ],
        "description": "Returns an index-based table with all matching player ids in ascending host queue order."
      },
      
      "players.get_boss": {
        "prefix": ["players.get_boss"],
        "body": [
          "players.get_boss(player_id)"
        ],
        "description": "Returns the organization (CEO/MC) boss player id of the player with the given ID. Returns -1 if not applicable."
      },
      
      "players.get_org_type": {
        "prefix": ["players.get_org_type"],
        "body": [
          "players.get_org_type(player_id)"
        ],
        "description": "Returns the organization (CEO/MC) type of the player with the given ID. Returns -1 for none, 0 for CEO, or 1 for Motorcycle Club."
      },
      
      "players.get_org_colour": {
        "prefix": ["players.get_org_colour"],
        "body": [
          "players.get_org_colour(player_id)"
        ],
        "description": "Returns the organization (CEO/MC) color of the player with the given ID. Returns -1 if not applicable. Add 192 to get the HUD color."
      },
      
      "players.clan_get_motto": {
        "prefix": ["players.clan_get_motto"],
        "body": [
          "players.clan_get_motto(player_id)"
        ],
        "description": "Returns the motto of the player's clan if applicable."
      },
      
      "players.get_position": {
        "prefix": ["players.get_position"],
        "body": [
          "players.get_position(player_id)"
        ],
        "description": "Returns the position (Vector3) of the player with the given ID. Works correctly at all distances."
      },
      
      "players.get_vehicle_model": {
        "prefix": ["players.get_vehicle_model"],
        "body": [
          "players.get_vehicle_model(player_id)"
        ],
        "description": "Returns the model of the vehicle the player with the given ID is in. Works at all distances but best when the user is close."
      },
      
      "players.is_using_rc_vehicle": {
        "prefix": ["players.is_using_rc_vehicle"],
        "body": [
          "players.is_using_rc_vehicle(player_id)"
        ],
        "description": "Checks if the player with the given ID is using an RC vehicle."
      },
      "players.get_bounty": {
        "prefix": ["players.get_bounty"],
        "body": [
          "players.get_bounty(player_id)"
        ],
        "description": "Returns the value of the player's bounty or nil."
      },
      
      "players.send_sms": {
        "prefix": ["players.send_sms"],
        "body": [
          "players.send_sms(recipient, text)"
        ],
        "description": "Sends an SMS to the specified recipient. The recipient must be a friend or a member of the same non-Rockstar crew. The message must be 1-255 characters."
      },
      
      "players.get_cam_pos": {
        "prefix": ["players.get_cam_pos"],
        "body": [
          "players.get_cam_pos(player_id)"
        ],
        "description": "Returns the position of the camera for the specified player as a Vector3."
      },
      
      "players.get_cam_rot": {
        "prefix": ["players.get_cam_rot"],
        "body": [
          "players.get_cam_rot(player_id)"
        ],
        "description": "Returns the rotation of the camera for the specified player as a Vector3."
      },
      
      "players.get_spectate_target": {
        "prefix": ["players.get_spectate_target"],
        "body": [
          "players.get_spectate_target(player_id)"
        ],
        "description": "Returns the player id being spectated or -1 if not applicable."
      },
      
      "players.get_waypoint": {
        "prefix": ["players.get_waypoint"],
        "body": [
          "players.get_waypoint(player_id)"
        ],
        "description": "Returns X, Y, Z, and a bool indicating if Z is guessed. Z is always guessed for remote players."
      },
      
      "players.get_net_player": {
        "prefix": ["players.get_net_player"],
        "body": [
          "players.get_net_player(player_id)"
        ],
        "description": "Returns the address of the player's CNetGamePlayer/rage::netPlayer instance or 0."
      },
      
      "players.set_wanted_level": {
        "prefix": ["players.set_wanted_level"],
        "body": [
          "players.set_wanted_level(player_id, wanted_level)"
        ],
        "description": "Sets the wanted level for the specified player."
      },
      
      "players.give_pickup_reward": {
        "prefix": ["players.give_pickup_reward"],
        "body": [
          "players.give_pickup_reward(player_id, reward)"
        ],
        "description": "Gives a pickup reward to the specified player. Valid rewards can be found in pickups.meta <Rewards> blocks."
      },
      
      "players.get_weapon_damage_modifier": {
        "prefix": ["players.get_weapon_damage_modifier"],
        "body": [
          "players.get_weapon_damage_modifier(player_id)"
        ],
        "description": "Returns the weapon damage modifier for the specified player."
      },
      
      "players.get_melee_weapon_damage_modifier": {
        "prefix": ["players.get_melee_weapon_damage_modifier"],
        "body": [
          "players.get_melee_weapon_damage_modifier(player_id)"
        ],
        "description": "Returns the melee weapon damage modifier for the specified player."
      },
      
      "players.add_detection": {
        "prefix": ["players.add_detection"],
        "body": [
          "players.add_detection(player_id, name, toast_flags = TOAST_DEFAULT, severity = 100)"
        ],
        "description": "Adds detection for the specified player with a label, toast flags, and severity."
      },
      
      "players.on_flow_event_done": {
        "prefix": ["players.on_flow_event_done"],
        "body": [
          "players.on_flow_event_done(callback)"
        ],
        "description": "Registers a function to be called when a flow event is done. Your callback will be called with the event's result."
      }
      "players.teleport_2d": {
        "prefix": ["players.teleport_2d"],
        "body": [
          "players.teleport_2d(player_id, x, y)"
        ],
        "description": "Teleports the specified player to the 2D coordinates (x, y)."
      },
      
      "players.teleport_3d": {
        "prefix": ["players.teleport_3d"],
        "body": [
          "players.teleport_3d(player_id, x, y, z)"
        ],
        "description": "Teleports the specified player to the 3D coordinates (x, y, z)."
      },
      //Entities Functions
      "entities.create_ped": {
        "prefix": ["entities.create_ped"],
        "body": [
          "entities.create_ped(type, hash, pos, heading)"
        ],
        "description": "Creates a pedestrian entity at the specified position and returns its handle. Returns INVALID_GUID on failure."
      },
      
      "entities.create_vehicle": {
        "prefix": ["entities.create_vehicle"],
        "body": [
          "entities.create_vehicle(hash, pos, heading)"
        ],
        "description": "Creates a vehicle entity at the specified position and returns its handle. Returns INVALID_GUID on failure."
      },
      
      "entities.create_object": {
        "prefix": ["entities.create_object"],
        "body": [
          "entities.create_object(hash, pos)"
        ],
        "description": "Creates an object entity at the specified position and returns its handle. Returns INVALID_GUID on failure."
      },
      
      "entities.get_user_vehicle_as_handle": {
        "prefix": ["entities.get_user_vehicle_as_handle"],
        "body": [
          "entities.get_user_vehicle_as_handle(include_last_vehicle)"
        ],
        "description": "Returns the handle of the user's vehicle or INVALID_GUID if not found."
      },
      
      "entities.get_user_vehicle_as_pointer": {
        "prefix": ["entities.get_user_vehicle_as_pointer"],
        "body": [
          "entities.get_user_vehicle_as_pointer(include_last_vehicle)"
        ],
        "description": "Returns the pointer to the user's vehicle or 0 if not found."
      },
      
      "entities.get_user_personal_vehicle_as_handle": {
        "prefix": ["entities.get_user_personal_vehicle_as_handle"],
        "body": [
          "entities.get_user_personal_vehicle_as_handle()"
        ],
        "description": "Returns the handle of the user's personal vehicle."
      },
      
      "entities.handle_to_pointer": {
        "prefix": ["entities.handle_to_pointer"],
        "body": [
          "entities.handle_to_pointer(handle)"
        ],
        "description": "Returns the address of the entity with the given script handle."
      },
      
      "entities.has_handle": {
        "prefix": ["entities.has_handle"],
        "body": [
          "entities.has_handle(addr)"
        ],
        "description": "Returns true if the entity with the given address has a script handle."
      },
      
      "entities.pointer_to_handle": {
        "prefix": ["entities.pointer_to_handle"],
        "body": [
          "entities.pointer_to_handle(addr)"
        ],
        "description": "Returns a script handle for the entity with the given address. If the entity does not have a script handle, one will be assigned to it."
      },
      
      "entities.get_all_vehicles_as_handles": {
        "prefix": ["entities.get_all_vehicles_as_handles"],
        "body": [
          "entities.get_all_vehicles_as_handles()"
        ],
        "description": "Returns an index-based table with handles for all vehicles. Allocates script handles for all vehicles."
      },
      
      "entities.get_all_vehicles_as_pointers": {
        "prefix": ["entities.get_all_vehicles_as_pointers"],
        "body": [
          "entities.get_all_vehicles_as_pointers()"
        ],
        "description": "Returns an index-based table with pointers for all vehicles. Allocates script handles for all vehicles."
      },
      
      "entities.get_all_peds_as_handles": {
        "prefix": ["entities.get_all_peds_as_handles"],
        "body": [
          "entities.get_all_peds_as_handles()"
        ],
        "description": "Returns an index-based table with handles for all peds. Allocates script handles for all peds."
      },
      
      "entities.get_all_peds_as_pointers": {
        "prefix": ["entities.get_all_peds_as_pointers"],
        "body": [
          "entities.get_all_peds_as_pointers()"
        ],
        "description": "Returns an index-based table with pointers for all peds. Allocates script handles for all peds."
      },
      
      "entities.get_all_objects_as_handles": {
        "prefix": ["entities.get_all_objects_as_handles"],
        "body": [
          "entities.get_all_objects_as_handles()"
        ],
        "description": "Returns an index-based table with handles for all objects. Allocates script handles for all objects."
      },
      
      "entities.get_all_objects_as_pointers": {
        "prefix": ["entities.get_all_objects_as_pointers"],
        "body": [
          "entities.get_all_objects_as_pointers()"
        ],
        "description": "Returns an index-based table with pointers for all objects. Allocates script handles for all objects."
      },
      
      "entities.get_all_pickups_as_handles": {
        "prefix": ["entities.get_all_pickups_as_handles"],
        "body": [
          "entities.get_all_pickups_as_handles()"
        ],
        "description": "Returns an index-based table with handles for all pickups. Allocates script handles for all pickups."
      },
      
      "entities.get_all_pickups_as_pointers": {
        "prefix": ["entities.get_all_pickups_as_pointers"],
        "body": [
          "entities.get_all_pickups_as_pointers()"
        ],
        "description": "Returns an index-based table with pointers for all pickups. Allocates script handles for all pickups."
      },
      
      "entities.delete": {
        "prefix": ["entities.delete"],
        "body": [
          "entities.delete(handle_or_ptr)"
        ],
        "description": "Deletes the specified entity. Handles control requests and forces deletion locally if control cannot be obtained."
      },
      
      "entities.get_model_hash": {
        "prefix": ["entities.get_model_hash"],
        "body": [
          "entities.get_model_hash(handle_or_ptr)"
        ],
        "description": "Returns the model hash of the specified entity."
      },
      
      "entities.get_position": {
        "prefix": ["entities.get_position"],
        "body": [
          "entities.get_position(addr)"
        ],
        "description": "Returns the position of the specified entity. The result might be less precise than the native counterpart."
      },
      
      "entities.get_rotation": {
        "prefix": ["entities.get_rotation"],
        "body": [
          "entities.get_rotation(addr)"
        ],
        "description": "Returns the rotation of the specified entity. The result might be less precise than the native counterpart."
      },
      
      "entities.get_health": {
        "prefix": ["entities.get_health"],
        "body": [
          "entities.get_health(handle_or_ptr)"
        ],
        "description": "Returns the health of the specified entity."
      },
      
      "entities.get_upgrade_value": {
        "prefix": ["entities.get_upgrade_value"],
        "body": [
          "entities.get_upgrade_value(handle_or_ptr, modType)"
        ],
        "description": "Returns the upgrade value of the specified modification type for the entity."
      },
      
      "entities.get_upgrade_max_value": {
        "prefix": ["entities.get_upgrade_max_value"],
        "body": [
          "entities.get_upgrade_max_value(handle_or_ptr, modType)"
        ],
        "description": "Returns the maximum upgrade value of the specified modification type for the entity."
      },
      
      "entities.set_upgrade_value": {
        "prefix": ["entities.set_upgrade_value"],
        "body": [
          "entities.set_upgrade_value(handle_or_ptr, modType, value)"
        ],
        "description": "Sets the upgrade value of the specified modification type for the entity."
      },
      
      "entities.get_current_gear": {
        "prefix": ["entities.get_current_gear"],
        "body": [
          "entities.get_current_gear(addr)"
        ],
        "description": "Returns the current gear of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.set_current_gear": {
        "prefix": ["entities.set_current_gear"],
        "body": [
          "entities.set_current_gear(addr, current_gear)"
        ],
        "description": "Sets the current gear of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.get_next_gear": {
        "prefix": ["entities.get_next_gear"],
        "body": [
          "entities.get_next_gear(addr)"
        ],
        "description": "Returns the next gear of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.set_next_gear": {
        "prefix": ["entities.set_next_gear"],
        "body": [
          "entities.set_next_gear(addr, next_gear)"
        ],
        "description": "Sets the next gear of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.get_rpm": {
        "prefix": ["entities.get_rpm"],
        "body": [
          "entities.get_rpm(addr)"
        ],
        "description": "Returns the RPM of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.set_rpm": {
        "prefix": ["entities.set_rpm"],
        "body": [
          "entities.set_rpm(addr, rpm)"
        ],
        "description": "Sets the RPM of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.get_gravity": {
        "prefix": ["entities.get_gravity"],
        "body": [
          "entities.get_gravity(addr)"
        ],
        "description": "Returns the gravity of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.set_gravity": {
        "prefix": ["entities.set_gravity"],
        "body": [
          "entities.set_gravity(addr, gravity)"
        ],
        "description": "Sets the gravity of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.set_gravity_multiplier": {
        "prefix": ["entities.set_gravity_multiplier"],
        "body": [
          "entities.set_gravity_multiplier(addr, gravity_multiplier)"
        ],
        "description": "Sets the gravity multiplier of the specified vehicle. Only applicable to vehicles."
      },
      
      "entities.get_boost_charge": {
        "prefix": ["entities.get_boost_charge"],
        "body": [
          "entities.get_boost_charge(addr)"
        ],
        "description": "Returns the boost charge of the specified vehicle. Only applicable to vehicles. Returns a value between 0.0 and 1.25."
      },
      
      "entities.get_draw_handler": {
        "prefix": ["entities.get_draw_handler"],
        "body": [
          "entities.get_draw_handler(addr)"
        ],
        "description": "Returns a pointer or 0 for the draw handler of the specified entity."
      },
      
      "entities.vehicle_draw_handler_get_pearlecent_colour": {
        "prefix": ["entities.vehicle_draw_handler_get_pearlecent_colour"],
        "body": [
          "entities.vehicle_draw_handler_get_pearlecent_colour(addr)"
        ],
        "description": "Returns the pearlescent colour of the vehicle. Only applicable to vehicles."
      },
      
      "entities.vehicle_draw_handler_get_wheel_colour": {
        "prefix": ["entities.vehicle_draw_handler_get_wheel_colour"],
        "body": [
          "entities.vehicle_draw_handler_get_wheel_colour(addr)"
        ],
        "description": "Returns the wheel colour of the vehicle. Only applicable to vehicles."
      },
      
      "entities.get_vehicle_has_been_owned_by_player": {
        "prefix": ["entities.get_vehicle_has_been_owned_by_player"],
        "body": [
          "entities.get_vehicle_has_been_owned_by_player(addr)"
        ],
        "description": "Returns true if the vehicle has been owned by a player."
      },
      
      "entities.get_player_info": {
        "prefix": ["entities.get_player_info"],
        "body": [
          "entities.get_player_info(addr)"
        ],
        "description": "Returns player information. Only applicable to peds."
      },
      
      "entities.player_info_get_game_state": {
        "prefix": ["entities.player_info_get_game_state"],
        "body": [
          "entities.player_info_get_game_state(addr)"
        ],
        "description": "Returns the game state of the player. Only applicable to peds."
      },
      
      "entities.get_weapon_manager": {
        "prefix": ["entities.get_weapon_manager"],
        "body": [
          "entities.get_weapon_manager(addr)"
        ],
        "description": "Returns the weapon manager. Only applicable to peds."
      },
      
      "entities.get_head_blend_data": {
        "prefix": ["entities.get_head_blend_data"],
        "body": [
          "entities.get_head_blend_data(handle_or_ptr)"
        ],
        "description": "Returns the head blend data of the specified entity."
      },
      
      "entities.get_owner": {
        "prefix": ["entities.get_owner"],
        "body": [
          "entities.get_owner(handle_or_ptr)"
        ],
        "description": "Returns the ID of the player that owns this entity."
      },
      "entities.set_can_migrate": {
        "prefix": ["entities.set_can_migrate"],
        "body": [
          "entities.set_can_migrate(handle_or_ptr, can_migrate)"
        ],
        "description": "Prevents ambient ownership changes so that only explicit requests will be processed."
      },
      
      "entities.get_can_migrate": {
        "prefix": ["entities.get_can_migrate"],
        "body": [
          "entities.get_can_migrate(handle_or_ptr)"
        ],
        "description": "Returns whether ambient ownership changes are prevented for the specified entity."
      },
      
      "entities.give_control": {
        "prefix": ["entities.give_control"],
        "body": [
          "entities.give_control(handle_or_ptr, player)"
        ],
        "description": "Gives control of the specified entity to the specified player."
      },
      
      "entities.vehicle_get_handling": {
        "prefix": ["entities.vehicle_get_handling"],
        "body": [
          "entities.vehicle_get_handling(addr)"
        ],
        "description": "Returns the handling hash of the specified vehicle."
      },
      
      "entities.handling_get_subhandling": {
        "prefix": ["entities.handling_get_subhandling"],
        "body": [
          "entities.handling_get_subhandling(handling_addr, type)"
        ],
        "description": "Returns the subhandling value for the specified handling type of the vehicle."
      },
      
      "entities.detach_wheel": {
        "prefix": ["entities.detach_wheel"],
        "body": [
          "entities.detach_wheel(handle_or_ptr, wheel_index)"
        ],
        "description": "Detaches the specified wheel from the specified vehicle."
      },
      
      "entities.is_player_ped": {
        "prefix": ["entities.is_player_ped"],
        "body": [
          "entities.is_player_ped(handle_or_ptr)"
        ],
        "description": "Returns true if the specified entity is a player ped."
      },
      
      "entities.is_invulnerable": {
        "prefix": ["entities.is_invulnerable"],
        "body": [
          "entities.is_invulnerable(handle_or_ptr)"
        ],
        "description": "Returns true if the specified entity is invulnerable."
      },
      
      "entities.request_control": {
        "prefix": ["entities.request_control"],
        "body": [
          "entities.request_control(handle_or_ptr, timeout)"
        ],
        "description": "Requests control of the specified entity. Returns false if control could not be attained within the specified timeout."
      },
      //Chat Functions
      "chat.on_message": {
        "prefix": ["chat.on_message"],
        "body": [
          "chat.on_message(callback)"
        ],
        "description": "Registers a function to be called when a chat message is received. The callback function will be called with the message as an argument."
      },
      "chat.send_message": {
        "prefix": ["chat.send_message"],
        "body": [
          "chat.send_message(\"${1:text}\", ${2:true}, ${3:true}, ${4:true})"
        ],
        "description": "Sends a chat message. The text may contain sequences like ${nl}, ${name}, ${ip}, ${geoip.isp}, ${geoip.country}, ${geoip.region}, ${geoip.city}. Messages have a limit of 140 UTF-16 characters, but can use up to 254 UTF-8 characters over the network."
      },
      "chat.send_targeted_message": {
        "prefix": ["chat.send_targeted_message"],
        "body": [
          "chat.send_targeted_message(${1:recipient}, ${2:sender}, \"${3:text}\", ${4:true})"
        ],
        "description": "Sends a targeted chat message. Sender is respected only when recipient is the user. The text may contain sequences like ${nl}, ${name}, ${ip}, ${geoip.isp}, ${geoip.country}, ${geoip.region}, ${geoip.city}."
      },
      "chat.get_state": {
        "prefix": ["chat.get_state"],
        "body": [
          "chat.get_state()"
        ],
        "description": "Gets the current state of the chat. Possible return values: 0 = Closed, 1 = Writing in team chat, 2 = Writing in all chat."
      },
      "chat.is_open": {
        "prefix": ["chat.is_open"],
        "body": [
          "chat.is_open()"
        ],
        "description": "Checks if the chat is open."
      },
      "chat.open": {
        "prefix": ["chat.open"],
        "body": [
          "chat.open()"
        ],
        "description": "Opens the chat."
      },
      "chat.close": {
        "prefix": ["chat.close"],
        "body": [
          "chat.close()"
        ],
        "description": "Closes the chat."
      },
      "chat.get_draft": {
        "prefix": ["chat.get_draft"],
        "body": [
          "chat.get_draft()"
        ],
        "description": "Gets the message that the user is currently drafting or an empty string if not applicable."
      },
      "chat.ensure_open_with_empty_draft": {
        "prefix": ["chat.ensure_open_with_empty_draft"],
        "body": [
          "chat.ensure_open_with_empty_draft(${1:true})"
        ],
        "description": "Ensures the chat is open with an empty draft. Can specify if it's for team chat."
      },
      "chat.add_to_draft": {
        "prefix": ["chat.add_to_draft"],
        "body": [
          "chat.add_to_draft(\"${1:appendix}\")"
        ],
        "description": "Adds an appendix to the chat draft."
      },
      "chat.remove_from_draft": {
        "prefix": ["chat.remove_from_draft"],
        "body": [
          "chat.remove_from_draft(${1:characters})"
        ],
        "description": "Removes a specified number of characters from the chat draft."
      },
      "chat.chat.get_history": {
        "prefix": ["chat.chat.get_history"],
        "body": [
          "chat.chat.get_history()"
        ],
        "description": "Gets the chat history as a table of tables, each containing 'text' and 'timestamp'."
      },
      //DirectX Functions
      "directx.create_texture": {
        "prefix": ["directx.create_texture"],
        "body": [
          "directx.create_texture(\"${1:path}\")"
        ],
        "description": "Creates a DirectX texture. An absolute path is recommended, e.g., by using filesystem.resources_dir()."
      },
      "directx.draw_texture": {
        "prefix": ["directx.draw_texture"],
        "body": [
          "directx.draw_texture(${1:id}, ${2:sizeX}, ${3:sizeY}, ${4:centerX}, ${5:centerY}, ${6:posX}, ${7:posY}, ${8:rotation}, ${9:Colour})"
        ],
        "description": "Draws a DirectX texture with the specified parameters."
      },
      "directx.create_font": {
        "prefix": ["directx.create_font"],
        "body": [
          "directx.create_font(\"${1:path}\")"
        ],
        "description": "Creates a DirectX font. An absolute path is recommended."
      },
      "directx.draw_text": {
        "prefix": ["directx.draw_text"],
        "body": [
          "directx.draw_text(${1:x}, ${2:y}, \"${3:text}\", ${4:alignment}, ${5:scale}, ${6:Colour}, ${7:false}, ${8:font})"
        ],
        "description": "Draws text using DirectX with the specified parameters. Alignment can be one of: ALIGN_TOP_LEFT, ALIGN_TOP_CENTRE, ALIGN_TOP_RIGHT, ALIGN_CENTRE_LEFT, ALIGN_CENTRE, ALIGN_CENTRE_RIGHT, ALIGN_BOTTOM_LEFT, ALIGN_BOTTOM_CENTRE, ALIGN_BOTTOM_RIGHT."
      },
      "directx.draw_rect": {
        "prefix": ["directx.draw_rect"],
        "body": [
          "directx.draw_rect(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:Colour})"
        ],
        "description": "Draws a rectangle using DirectX with the specified parameters."
      },
      "directx.draw_line": {
        "prefix": ["directx.draw_line"],
        "body": [
          "directx.draw_line(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:Colour})"
        ],
        "description": "Draws a line using DirectX with the specified parameters."
      },
      "directx.draw_triangle": {
        "prefix": ["directx.draw_triangle"],
        "body": [
          "directx.draw_triangle(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:Colour})"
        ],
        "description": "Draws a triangle using DirectX with the specified parameters."
      },
      "directx.get_client_size": {
        "prefix": ["directx.get_client_size"],
        "body": [
          "directx.get_client_size()"
        ],
        "description": "Gets the client size as width and height."
      },
      "directx.get_text_size": {
        "prefix": ["directx.get_text_size"],
        "body": [
          "directx.get_text_size(\"${1:text}\", ${2:scale}, ${3:font})"
        ],
        "description": "Gets the size of the text as width and height using DirectX."
      },
      "directx.pos_hud_to_client": {
        "prefix": ["directx.pos_hud_to_client"],
        "body": [
          "directx.pos_hud_to_client(${1:x}, ${2:y})"
        ],
        "description": "Converts HUD position to client position."
      },
      "directx.size_hud_to_client": {
        "prefix": ["directx.size_hud_to_client"],
        "body": [
          "directx.size_hud_to_client(${1:x}, ${2:y})"
        ],
        "description": "Converts HUD size to client size."
      },
      "directx.pos_client_to_hud": {
        "prefix": ["directx.pos_client_to_hud"],
        "body": [
          "directx.pos_client_to_hud(${1:x}, ${2:y})"
        ],
        "description": "Converts client position to HUD position."
      },
      "directx.size_client_to_hud": {
        "prefix": ["directx.size_client_to_hud"],
        "body": [
          "directx.size_client_to_hud(${1:x}, ${2:y})"
        ],
        "description": "Converts client size to HUD size."
      },
      "directx.blurrect_new": {
        "prefix": ["directx.blurrect_new"],
        "body": [
          "directx.blurrect_new()"
        ],
        "description": "Creates a new Blurrect instance."
      },
      "directx.blurrect_free": {
        "prefix": ["directx.blurrect_free"],
        "body": [
          "directx.blurrect_free(${1:instance})"
        ],
        "description": "Frees a Blurrect instance."
      },
      "directx.blurrect_draw": {
        "prefix": ["directx.blurrect_draw"],
        "body": [
          "directx.blurrect_draw(${1:instance}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:strength})"
        ],
        "description": "Draws with Blurrect using the specified instance and parameters."
      }
      //Util Functions
      "util.require_natives": {
        "prefix": ["util.require_natives"],
        "body": [
          "util.require_natives(${1:version}, ${2:flavour})"
        ],
        "description": "Loads the natives lib with the provided version, installing it from the repository if needed."
      },
      "util.execute_in_os_thread": {
        "prefix": ["util.execute_in_os_thread"],
        "body": [
          "util.execute_in_os_thread(function(${1:args})"
        ],
        "description": "Executes the given function in an OS thread to avoid holding up the game for expensive tasks like using require on a big file, creating lots of commands, or performing expensive calculations. Note that this will hold up your entire script, and calling natives or certain api functions in this context may lead to instabilities."
      },
      "util.require_no_lag": {
        "prefix": ["util.require_no_lag"],
        "body": [
          "util.require_no_lag(\"${1:file}\")"
        ],
        "description": "Like require, but in an OS thread, to avoid holding up the game. Might not work for every library."
      },
      "util.create_tick_handler": {
        "prefix": ["util.create_tick_handler"],
        "body": [
          "util.create_tick_handler(function(${1:args})"
        ],
        "description": "Registers the parameter-function to be called every tick until it returns false."
      }
      "util.try_run": {
        "prefix": ["util.try_run"],
        "body": [
          "util.try_run(function(${1:args})"
        ],
        "description": "Executes the given function and prevents Stand from cleaning up your script for being idle. Implicit when creating commands, registering event handlers, or using the async_http API."
      },
      "util.keep_running": {
        "prefix": ["util.keep_running"],
        "body": [
          "util.keep_running()"
        ],
        "description": "Prevents Stand from cleaning up your script for being idle. This is implicit when you create commands, register event handlers, or use the async_http API."
      },
      "util.yield": {
        "prefix": ["util.yield"],
        "body": [
          "util.yield(${1:wake_in_ms})"
        ],
        "description": "Pauses the execution of the calling thread until the next tick or in wake_in_ms milliseconds. If you're going to create a 'neverending' loop, don't forget to yield."
      },
      "util.can_continue": {
        "prefix": ["util.can_continue"],
        "body": [
          "util.can_continue()"
        ],
        "description": "Returns two booleans. The first remains true until your script is being stopped. The second indicates if a silent stop of your script has been requested."
      },
      "util.set_busy": {
        "prefix": ["util.set_busy"],
        "body": [
          "util.set_busy(${1:true})"
        ],
        "description": "Sets the busy state of your script."
      },
      "util.create_thread": {
        "prefix": ["util.create_thread"],
        "body": [
          "util.create_thread(function(${1:args})"
        ],
        "description": "Creates a thread that gets resumed every tick and is expected to yield or return."
      },
      "util.stop_thread": {
        "prefix": ["util.stop_thread"],
        "body": [
          "util.stop_thread()"
        ],
        "description": "Stops the calling thread."
      },
      "util.restart_script": {
        "prefix": ["util.restart_script"],
        "body": [
          "util.restart_script()"
        ],
        "description": "Restarts the script. Goes through the script stop process, freshly loads the contents of the script file, and starts the main thread again."
      },
      "util.stop_script": {
        "prefix": ["util.stop_script"],
        "body": [
          "util.stop_script()"
        ],
        "description": "Stops the script. The script stop process involves on_pre_stop and on_stop handlers."
      },
      "util.on_pre_stop": {
        "prefix": ["util.on_pre_stop"],
        "body": [
          "util.on_pre_stop(function(${1:args})"
        ],
        "description": "Registers a function to be called during the script stop process before on_stop handlers."
      },
      "util.on_stop": {
        "prefix": ["util.on_stop"],
        "body": [
          "util.on_stop(function(${1:args})"
        ],
        "description": "Registers a function to be called during the script stop process after on_pre_stop handlers."
      },
      "util.toast": {
        "prefix": ["util.toast"],
        "body": [
          "util.toast(\"${1:Message}\", ${2:TOAST_DEFAULT})"
        ],
        "description": "Shows a notification with optional bitflags for different locations and channels."
      },
      "util.log": {
        "prefix": ["util.log"],
        "body": [
          "util.log(\"${1:Message}\")"
        ],
        "description": "Logs a message using Stand's logging system. Equivalent to util.toast(message, TOAST_LOGGER)."
      },
      "util.draw_debug_text": {
        "prefix": ["util.draw_debug_text"],
        "body": [
          "util.draw_debug_text(\"${1:Text}\")"
        ],
        "description": "Draws the given text for the current tick using the 'Info Text' system."
      },
      "util.draw_centred_text": {
        "prefix": ["util.draw_centred_text"],
        "body": [
          "util.draw_centred_text(\"${1:Text}\")"
        ],
        "description": "Draws centred text using the 'Info Text' system."
      },
      "util.show_corner_help": {
        "prefix": ["util.show_corner_help"],
        "body": [
          "util.show_corner_help(\"${1:Message}\")"
        ],
        "description": "Shows corner help with the specified message."
      },
      "util.replace_corner_help": {
        "prefix": ["util.replace_corner_help"],
        "body": [
          "util.replace_corner_help(\"${1:CurrentMessage}\", \"${2:ReplacementMessage}\")"
        ],
        "description": "Replaces the corner help message with the specified replacement message."
      },
      "util.set_local_player_wanted_level": {
        "prefix": ["util.set_local_player_wanted_level"],
        "body": [
          "util.set_local_player_wanted_level(${1:wanted_level})"
        ],
        "description": "Sets the wanted level for the local player."
      },
      "util.joaat": {
        "prefix": ["util.joaat"],
        "body": [
          "util.joaat(${1:text})"
        ],
        "description": "Produces the hash used in GTA for the given text (computed as lowercase)."
      },
      "util.ujoaat": {
        "prefix": ["util.ujoaat"],
        "body": [
          "util.ujoaat(${1:text})"
        ],
        "description": "Produces the uppercase hash used in GTA for the given text."
      }
      "util.reverse_joaat": {
        "prefix": ["util.reverse_joaat"],
        "body": [
          "util.reverse_joaat(${1:hash})"
        ],
        "description": "Returns the text representation of the given hash (computed as lowercase). Returns an empty string if not found in Stand's dictionaries."
      },
      "util.is_this_model_a_blimp": {
        "prefix": ["util.is_this_model_a_blimp"],
        "body": [
          "util.is_this_model_a_blimp(${1:model})"
        ],
        "description": "Checks if the given model is a blimp."
      },
      "util.is_this_model_an_object": {
        "prefix": ["util.is_this_model_an_object"],
        "body": [
          "util.is_this_model_an_object(${1:model})"
        ],
        "description": "Checks if the given model is an object."
      },
      "util.is_this_model_a_submarine": {
        "prefix": ["util.is_this_model_a_submarine"],
        "body": [
          "util.is_this_model_a_submarine(${1:model})"
        ],
        "description": "Checks if the given model is a submarine."
      },
      "util.is_this_model_a_submarine_car": {
        "prefix": ["util.is_this_model_a_submarine_car"],
        "body": [
          "util.is_this_model_a_submarine_car(${1:model})"
        ],
        "description": "Checks if the given model is a submarine car."
      },
      "util.is_this_model_a_trailer": {
        "prefix": ["util.is_this_model_a_trailer"],
        "body": [
          "util.is_this_model_a_trailer(${1:model})"
        ],
        "description": "Checks if the given model is a trailer."
      },
      "util.get_vehicles": {
        "prefix": ["util.get_vehicles"],
        "body": [
          "util.get_vehicles()"
        ],
        "description": "Returns a table with information about each vehicle in the game, including name, manufacturer, and class."
      },
      "util.get_objects": {
        "prefix": ["util.get_objects"],
        "body": [
          "util.get_objects()"
        ],
        "description": "Returns a table with information about each object in the game."
      },
      "util.get_weapons": {
        "prefix": ["util.get_weapons"],
        "body": [
          "util.get_weapons()"
        ],
        "description": "Returns a table with information about each weapon in the game, including hash, label key, category, and category ID."
      },
      "util.BEGIN_TEXT_COMMAND_DISPLAY_TEXT": {
        "prefix": ["util.BEGIN_TEXT_COMMAND_DISPLAY_TEXT"],
        "body": [
          "util.BEGIN_TEXT_COMMAND_DISPLAY_TEXT(${1:message})"
        ],
        "description": "Begins a text command to display the given text."
      },
      "util._BEGIN_TEXT_COMMAND_LINE_COUNT": {
        "prefix": ["util._BEGIN_TEXT_COMMAND_LINE_COUNT"],
        "body": [
          "util._BEGIN_TEXT_COMMAND_LINE_COUNT(${1:message})"
        ],
        "description": "Begins a text command to determine the line count for the given text."
      }
      "util.BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED": {
        "prefix": ["util.BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED"],
        "body": [
          "util.BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(${1:message})"
        ],
        "description": "Begins a text command to check if the specified help message is being displayed."
      },
      "util.BEGIN_TEXT_COMMAND_DISPLAY_HELP": {
        "prefix": ["util.BEGIN_TEXT_COMMAND_DISPLAY_HELP"],
        "body": [
          "util.BEGIN_TEXT_COMMAND_DISPLAY_HELP(${1:message})"
        ],
        "description": "Begins a text command to display a help message."
      },
      "util._BEGIN_TEXT_COMMAND_GET_WIDTH": {
        "prefix": ["util._BEGIN_TEXT_COMMAND_GET_WIDTH"],
        "body": [
          "util._BEGIN_TEXT_COMMAND_GET_WIDTH(${1:message})"
        ],
        "description": "Begins a text command to get the width of the specified text."
      },
      "util.BEGIN_TEXT_COMMAND_THEFEED_POST": {
        "prefix": ["util.BEGIN_TEXT_COMMAND_THEFEED_POST"],
        "body": [
          "util.BEGIN_TEXT_COMMAND_THEFEED_POST(${1:message})"
        ],
        "description": "Begins a text command to post a message to The Feed."
      },
      "util.get_rp_required_for_rank": {
        "prefix": ["util.get_rp_required_for_rank"],
        "body": [
          "util.get_rp_required_for_rank(${1:rank})"
        ],
        "description": "Gets the RP required for a specific rank."
      },
      "util.get_session_players_bitflag": {
        "prefix": ["util.get_session_players_bitflag"],
        "body": [
          "util.get_session_players_bitflag()"
        ],
        "description": "Gets the bitflag for session players."
      },
      "util.trigger_script_event": {
        "prefix": ["util.trigger_script_event"],
        "body": [
          "util.trigger_script_event(${1:session_player_bitflags}, ${2:args}, ${3:reinterpret_floats})"
        ],
        "description": "Triggers a script event with optional parameters."
      },
      "util.current_time_millis": {
        "prefix": ["util.current_time_millis"],
        "body": [
          "util.current_time_millis()"
        ],
        "description": "Gets the current time in milliseconds."
      },
      "util.current_unix_time_seconds": {
        "prefix": ["util.current_unix_time_seconds"],
        "body": [
          "util.current_unix_time_seconds()"
        ],
        "description": "Gets the current UNIX time in seconds."
      },
      "util.remove_handler": {
        "prefix": ["util.remove_handler"],
        "body": [
          "util.remove_handler(${1:handler_id})"
        ],
        "description": "Removes a registered handler."
      },
      "util.is_session_started": {
        "prefix": ["util.is_session_started"],
        "body": [
          "util.is_session_started()"
        ],
        "description": "Checks if the session has started."
      },
      "util.is_session_transition_active": {
        "prefix": ["util.is_session_transition_active"],
        "body": [
          "util.is_session_transition_active()"
        ],
        "description": "Checks if a session transition is active."
      },
      "util.get_char_slot": {
        "prefix": ["util.get_char_slot"],
        "body": [
          "util.get_char_slot()"
        ],
        "description": "Gets the character slot."
      },
      "util.get_ground_z": {
        "prefix": ["util.get_ground_z"],
        "body": [
          "util.get_ground_z(${1:x}, ${2:y}, ${3:z_hint})"
        ],
        "description": "Gets the precise ground Z coordinate."
      },
      "util.spoof_script": {
        "prefix": ["util.spoof_script"],
        "body": [
          "util.spoof_script(${1:script}, function(${2:...})",
          "${3:  })"
        ],
        "description": "Spoofs a script and executes a function."
      },
      "util.spoof_script_thread": {
        "prefix": ["util.spoof_script_thread"],
        "body": [
          "util.spoof_script_thread(${1:thread_id}, function(${2:...})",
          "${3:  })"
        ],
        "description": "Spoofs a script thread and executes a function."
      },
      "util.remove_blip": {
        "prefix": ["util.remove_blip"],
        "body": [
          "util.remove_blip(${1:blip})"
        ],
        "description": "Removes a blip."
      },
      "util.arspinner_enable": {
        "prefix": ["util.arspinner_enable"],
        "body": [
          "util.arspinner_enable()"
        ],
        "description": "Enables the AR spinner."
      },
      "util.arspinner_disable": {
        "prefix": ["util.arspinner_disable"],
        "body": [
          "util.arspinner_disable()"
        ],
        "description": "Disables the AR spinner."
      },
      "util.is_bigmap_active": {
        "prefix": ["util.is_bigmap_active"],
        "body": [
          "util.is_bigmap_active()"
        ],
        "description": "Checks if the big map is active."
      },
      "util.copy_to_clipboard": {
        "prefix": ["util.copy_to_clipboard"],
        "body": [
          "util.copy_to_clipboard(${1:text}, ${2:notify})"
        ],
        "description": "Copies text to the clipboard."
      },
      "util.get_clipboard_text": {
        "prefix": ["util.get_clipboard_text"],
        "body": [
          "util.get_clipboard_text()"
        ],
        "description": "Gets the text from the clipboard."
      },
      "util.read_colons_and_tabs_file": {
        "prefix": ["util.read_colons_and_tabs_file"],
        "body": [
          "util.read_colons_and_tabs_file(${1:file})"
        ],
        "description": "Reads a file in colons and tabs format."
      },
      "util.write_colons_file": {
        "prefix": ["util.write_colons_file"],
        "body": [
          "util.write_colons_file(${1:file}, ${2:data})"
        ],
        "description": "Writes a file in colons and tabs format."
      },
      "util.draw_ar_beacon": {
        "prefix": ["util.draw_ar_beacon"],
        "body": [
          "util.draw_ar_beacon(${1:pos})"
        ],
        "description": "Draws an AR beacon at the specified position."
      },
      "util.draw_box": {
        "prefix": ["util.draw_box"],
        "body": [
          "util.draw_box(${1:pos}, ${2:rot}, ${3:dimensions}, ${4:r}, ${5:g}, ${6:b}, ${7:a})"
        ],
        "description": "Draws a box with 3D rotation using polys."
      },
      "util.request_script_host": {
        "prefix": ["util.request_script_host"],
        "body": [
          "util.request_script_host(${1:script})"
        ],
        "description": "Requests script host for a script."
      },
      "util.give_script_host": {
        "prefix": ["util.give_script_host"],
        "body": [
          "util.give_script_host(${1:script}, ${2:player})"
        ],
        "description": "Gives script host to a player for a script."
      },
      "util.register_file": {
        "prefix": ["util.register_file"],
        "body": [
          "util.register_file(${1:path})"
        ],
        "description": "Registers a file in the game for use with natives."
      },
      "util.get_label_text": {
        "prefix": ["util.get_label_text"],
        "body": [
          "util.get_label_text(${1:label_key})"
        ],
        "description": "Gets label text bypassing Stand replacements."
      },
      "util.register_label": {
        "prefix": ["util.register_label"],
        "body": [
          "util.register_label(${1:text})"
        ],
        "description": "Registers a label for use with HUD natives."
      },
      "util.is_key_down": {
        "prefix": ["util.is_key_down"],
        "body": [
          "util.is_key_down(${1:vk})"
        ],
        "description": "Checks if a key is currently down."
      },
      "util.call_foreign_function": {
        "prefix": ["util.call_foreign_function"],
        "body": [
          "util.call_foreign_function(${1:addr}, ${2:...})"
        ],
        "description": "Calls a foreign function at the specified address."
      },
      "util.get_rtti_name": {
        "prefix": ["util.get_rtti_name"],
        "body": [
          "util.get_rtti_name(${1:inst_addr})"
        ],
        "description": "Gets the RTTI name of an instance at the specified address."
      },
      "util.get_rtti_hierarchy": {
        "prefix": ["util.get_rtti_hierarchy"],
        "body": [
          "util.get_rtti_hierarchy(${1:inst_addr})"
        ],
        "description": "Gets the RTTI hierarchy of an instance at the specified address."
      },
      "util.set_particle_fx_asset": {
        "prefix": ["util.set_particle_fx_asset"],
        "body": [
          "util.set_particle_fx_asset(${1:hash})"
        ],
        "description": "Sets the particle FX asset for the game."
      },
      "util.blip_handle_to_pointer": {
        "prefix": ["util.blip_handle_to_pointer"],
        "body": [
          "util.blip_handle_to_pointer(${1:blip_handle})"
        ],
        "description": "Converts a blip handle to a pointer."
      },
      "util.get_blip_display": {
        "prefix": ["util.get_blip_display"],
        "body": [
          "util.get_blip_display(${1:blip_handle})"
        ],
        "description": "Gets the blip display ID for a blip handle."
      },
      "util.teleport_2d": {
        "prefix": ["util.teleport_2d"],
        "body": [
          "util.teleport_2d(${1:x}, ${2:y})"
        ],
        "description": "Teleports to a 2D position."
      },
      "util.is_interaction_menu_open": {
        "prefix": ["util.is_interaction_menu_open"],
        "body": [
          "util.is_interaction_menu_open()"
        ],
        "description": "Checks if the interaction menu is open."
      },
      "util.on_transition_finished": {
        "prefix": ["util.on_transition_finished"],
        "body": [
          "util.on_transition_finished(function(${1:...})",
          "${2:  })"
        ],
        "description": "Registers a callback for when the transition is finished."
      },
      "util.get_closest_hud_colour": {
        "prefix": ["util.get_closest_hud_colour"],
        "body": [
          "util.get_closest_hud_colour(${1:target_r}, ${2:target_g}, ${3:target_b}, ${4:target_a})"
        ],
        "description": "Gets the closest HUD colour."
      },
      "util.is_soup_netintel_inited": {
        "prefix": ["util.is_soup_netintel_inited"],
        "body": [
          "util.is_soup_netintel_inited()"
        ],
        "description": "Checks if SoupNetIntel is initialized."
      },
      "util.on_pad_shake": {
        "prefix": ["util.on_pad_shake"],
        "body": [
          "util.on_pad_shake(function(${1:...})",
          "${2:  })"
        ],
        "description": "Registers a callback for when the pad is shaken."
      },
      "util.request_model": {
        "prefix": ["util.request_model"],
        "body": [
          "util.request_model(${1:model}, ${2:timeout})"
        ],
        "description": "Attempts to load the given model within the specified timeout or throws an error."
      },
      "util.open_folder": {
        "prefix": ["util.open_folder"],
        "body": [
          "util.open_folder(${1:path})"
        ],
        "description": "Opens the specified folder path."
      },
      "util.set_nullptr_preference": {
        "prefix": ["util.set_nullptr_preference"],
        "body": [
          "util.set_nullptr_preference(${1:use_nil})"
        ],
        "description": "Sets the nullptr preference for Stand."
      },
      "util.get_tps": {
        "prefix": ["util.get_tps"],
        "body": [
          "util.get_tps()"
        ],
        "description": "Gets the ticks per second (TPS)."
      },
      "util.get_session_code": {
        "prefix": ["util.get_session_code"],
        "body": [
          "util.get_session_code()"
        ],
        "description": "Gets the session code."
      },
      "util.stat_get_type": {
        "prefix": ["util.stat_get_type"],
        "body": [
          "util.stat_get_type(${1:stat})"
        ],
        "description": "Gets the type of the specified stat."
      },
      "util.stat_get_int64": {
        "prefix": ["util.stat_get_int64"],
        "body": [
          "util.stat_get_int64(${1:stat})"
        ],
        "description": "Gets the int64 value of the specified stat."
      },
      "util.new_toast_config": {
        "prefix": ["util.new_toast_config"],
        "body": [
          "util.new_toast_config(${1:list}, ${2:bitflags}, ${3:command_names_prefix})"
        ],
        "description": "Creates a new toast configuration."
      },
      "util.toast_config_get_flags": {
        "prefix": ["util.toast_config_get_flags"],
        "body": [
          "util.toast_config_get_flags(${1:tc})"
        ],
        "description": "Gets the flags of the specified toast configuration."
      },
      "util.get_model_info": {
        "prefix": ["util.get_model_info"],
        "body": [
          "util.get_model_info(${1:hash})"
        ],
        "description": "Returns the address of the CModelInfo for the given hash or 0 if not loaded."
      },
      "util.is_valid_file_name": {
        "prefix": ["util.is_valid_file_name"],
        "body": [
          "util.is_valid_file_name(${1:name}, ${2:allow_folder})"
        ],
        "description": "Checks if the specified name is a valid file name."
      },
      "util.rgb2hsv": {
        "prefix": ["util.rgb2hsv"],
        "body": [
          "util.rgb2hsv(${1:r}, ${2:g}, ${3:b})"
        ],
        "description": "Converts RGB values to HSV."
      },
      "util.hsv2rgb": {
        "prefix": ["util.hsv2rgb"],
        "body": [
          "util.hsv2rgb(${1:h}, ${2:s}, ${3:v})"
        ],
        "description": "Converts HSV values to RGB."
      },
      "util.calculate_luminance": {
        "prefix": ["util.calculate_luminance"],
        "body": [
          "util.calculate_luminance(${1:r}, ${2:g}, ${3:b})"
        ],
        "description": "Calculates the luminance of a color."
      },
      "util.calculate_contrast": {
        "prefix": ["util.calculate_contrast"],
        "body": [
          "util.calculate_contrast(${1:r1}, ${2:g1}, ${3:b1}, ${4:r2}, ${5:g2}, ${6:b2})"
        ],
        "description": "Calculates the contrast between two colors."
      },
      "util.is_contrast_sufficient": {
        "prefix": ["util.is_contrast_sufficient"],
        "body": [
          "util.is_contrast_sufficient(${1:r1}, ${2:g1}, ${3:b1}, ${4:r2}, ${5:g2}, ${6:b2})"
        ],
        "description": "Checks if the contrast between two colors is sufficient."
      },
      "util.set_waypoint": {
        "prefix": ["util.set_waypoint"],
        "body": [
          "util.set_waypoint(${1:pos})"
        ],
        "description": "Sets a waypoint at the specified position."
      },
      "util.set_cam_quaternion": {
        "prefix": ["util.set_cam_quaternion"],
        "body": [
          "util.set_cam_quaternion(${1:cam}, ${2:x}, ${3:y}, ${4:z}, ${5:w})"
        ],
        "description": "Sets the quaternion of a camera."
      },
      "util.get_screen_coord_from_world_coord_no_adjustment": {
        "prefix": ["util.get_screen_coord_from_world_coord_no_adjustment"],
        "body": [
          "util.get_screen_coord_from_world_coord_no_adjustment(${1:fWorldX}, ${2:fWorldY}, ${3:fWorldZ}, ${4:pOutScreenX}, ${5:pOutScreenY})"
        ],
        "description": "Alternative to GRAPHICS.GET_SCREEN_COORD_FROM_WORLD_COORD without adjustments for multihead monitor configs."
      },
      "util.utf8_to_utf16": {
        "prefix": ["util.utf8_to_utf16"],
        "body": [
          "util.utf8_to_utf16(${1:utf8})"
        ],
        "description": "Converts a UTF-8 string to UTF-16."
      },
      "util.utf16_to_utf8": {
        "prefix": ["util.utf16_to_utf8"],
        "body": [
          "util.utf16_to_utf8(${1:utf16})"
        ],
        "description": "Converts a UTF-16 string to UTF-8."
      },
      "util.get_gps_route": {
        "prefix": ["util.get_gps_route"],
        "body": [
          "util.get_gps_route(${1:slot})"
        ],
        "description": "Gets the GPS route information for the given slot."
      },
      //V3 Functions
      "v3.new": {
        "prefix": ["v3.new"],
        "body": [
          "v3.new(${1:float x, float y, float z})"
        ],
        "description": "Creates a new v3 instance."
      },
      "v3.get": {
        "prefix": ["v3.get"],
        "body": [
          "v3.get(${1:userdata|int addr})"
        ],
        "description": "Gets the x, y, and z components of a v3 instance."
      },
      "v3.setX": {
        "prefix": ["v3.setX"],
        "body": [
          "v3.setX(${1:userdata|int addr}, ${2:float x})"
        ],
        "description": "Sets the x component of a v3 instance."
      },
      "v3.setY": {
        "prefix": ["v3.setY"],
        "body": [
          "v3.setY(${1:userdata|int addr}, ${2:float y})"
        ],
        "description": "Sets the y component of a v3 instance."
      },
      "v3.setZ": {
        "prefix": ["v3.setZ"],
        "body": [
          "v3.setZ(${1:userdata|int addr}, ${2:float z})"
        ],
        "description": "Sets the z component of a v3 instance."
      },
      "v3.add": {
        "prefix": ["v3.add"],
        "body": [
          "v3.add(${1:userdata|int a}, ${2:userdata|int b})"
        ],
        "description": "Adds two v3 instances and returns the result."
      },
      "v3.sub": {
        "prefix": ["v3.sub"],
        "body": [
          "v3.sub(${1:userdata|int a}, ${2:userdata|int b})"
        ],
        "description": "Subtracts one v3 instance from another and returns the result."
      },
      "v3.mul": {
        "prefix": ["v3.mul"],
        "body": [
          "v3.mul(${1:userdata|int a}, ${2:number f})"
        ],
        "description": "Multiplies a v3 instance by a scalar factor."
      },
      "v3.div": {
        "prefix": ["v3.div"],
        "body": [
          "v3.div(${1:userdata|int a}, ${2:number f})"
        ],
        "description": "Divides a v3 instance by a scalar factor."
      },
      "v3.magnitude": {
        "prefix": ["v3.magnitude"],
        "body": [
          "v3.magnitude(${1:userdata|int a})"
        ],
        "description": "Calculates the magnitude (length) of a v3 instance."
      },
      "v3.distance": {
        "prefix": ["v3.distance"],
        "body": [
          "v3.distance(${1:userdata|int a}, ${2:userdata|int b})"
        ],
        "description": "Calculates the distance between two v3 instances."
      },
      "v3.abs": {
        "prefix": ["v3.abs"],
        "body": [
          "v3.abs(${1:userdata|int addr})"
        ],
        "description": "Ensures that every axis of a v3 instance is positive."
      },
      "v3.min": {
        "prefix": ["v3.min"],
        "body": [
          "v3.min(${1:userdata|int addr})"
        ],
        "description": "Returns the value of the smallest axis of a v3 instance."
      },
      "v3.max": {
        "prefix": ["v3.max"],
        "body": [
          "v3.max(${1:userdata|int addr})"
        ],
        "description": "Returns the value of the biggest axis of a v3 instance."
      },
      "v3.dot": {
        "prefix": ["v3.dot"],
        "body": [
          "v3.dot(${1:userdata|int a}, ${2:int b})"
        ],
        "description": "Calculates the dot product of two v3 instances."
      },
      "v3.normalise": {
        "prefix": ["v3.normalise"],
        "body": [
          "v3.normalise(${1:userdata|int addr})"
        ],
        "description": "Normalizes a v3 instance, making it a unit vector."
      },
      "v3.toRot": {
        "prefix": ["v3.toRot"],
        "body": [
          "v3.toRot(${1:userdata|int addr})"
        ],
        "description": "Converts a v3 instance to a rotation instance."
      },
      "v3.lookAt": {
        "prefix": ["v3.lookAt"],
        "body": [
          "v3.lookAt(${1:userdata|int a}, ${2:int b})"
        ],
        "description": "Generates a rotation that makes one v3 instance look at another v3 instance."
      },
      "v3.toDir": {
        "prefix": ["v3.toDir"],
        "body": [
          "v3.toDir(${1:userdata|int addr})"
        ],
        "description": "Converts a v3 instance to a direction vector."
      },
      "v3.toString": {
        "prefix": ["v3.toString"],
        "body": [
          "v3.toString(${1:userdata|int addr})"
        ],
        "description": "Converts a v3 instance to a string."
      },
      //Lang Functions
      "lang.get_current": {
        "prefix": ["lang.get_current"],
        "body": [
          "lang.get_current()"
        ],
        "description": "Returns the current menu language."
      },
      "lang.is_code_valid": {
        "prefix": ["lang.is_code_valid"],
        "body": [
          "lang.is_code_valid(${1:string lang_code})"
        ],
        "description": "Checks if a language code is valid."
      },
      "lang.get_code_for_soup": {
        "prefix": ["lang.get_code_for_soup"],
        "body": [
          "lang.get_code_for_soup(${1:string lang_code})"
        ],
        "description": "Gets the language code for soup languages."
      },
      "lang.is_automatically_translated": {
        "prefix": ["lang.is_automatically_translated"],
        "body": [
          "lang.is_automatically_translated(${1:string lang_code})"
        ],
        "description": "Checks if a language is automatically translated."
      },
      "lang.is_english": {
        "prefix": ["lang.is_english"],
        "body": [
          "lang.is_english(${1:string lang_code})"
        ],
        "description": "Checks if a language is English."
      },
      "lang.register": {
        "prefix": ["lang.register"],
        "body": [
          "lang.register(${1:string text})"
        ],
        "description": "Registers a label for translation."
      },
      "lang.set_translate": {
        "prefix": ["lang.set_translate"],
        "body": [
          "lang.set_translate(${1:string lang_code})"
        ],
        "description": "Starts the process of translating labels."
      },
      "lang.translate": {
        "prefix": ["lang.translate"],
        "body": [
          "lang.translate(${1:int label}, ${2:string text})"
        ],
        "description": "Translates a label."
      },
      "lang.find": {
        "prefix": ["lang.find"],
        "body": [
          "lang.find(${1:string text}, ${2:string lang_code = 'en'})"
        ],
        "description": "Finds an existing label using its text."
      },
      "lang.find_builtin": {
        "prefix": ["lang.find_builtin"],
        "body": [
          "lang.find_builtin(${1:string text}, ${2:string lang_code = 'en'})"
        ],
        "description": "Finds a built-in label."
      },
      "lang.find_registered": {
        "prefix": ["lang.find_registered"],
        "body": [
          "lang.find_registered(${1:string text}, ${2:string lang_code = 'en'})"
        ],
        "description": "Finds a registered label."
      },
      "lang.get_string": {
        "prefix": ["lang.get_string"],
        "body": [
          "lang.get_string(${1:Label label}, ${2:string lang_code = 'en'})"
        ],
        "description": "Gets the string for a label."
      },
      "lang.get_localised": {
        "prefix": ["lang.get_localised"],
        "body": [
          "lang.get_localised(${1:Label label})"
        ],
        "description": "Gets the localized string for a label."
      },
      "lang.is_mine": {
        "prefix": ["lang.is_mine"],
        "body": [
          "lang.is_mine(${1:int label})"
        ],
        "description": "Checks if a label was registered by the calling script."
      },
      //Filesystem Functions
      "filesystem.appdata_dir": {
        "prefix": ["filesystem.appdata_dir"],
        "body": [
          "filesystem.appdata_dir()"
        ],
        "description": "Returns the AppData directory path."
      },
      "filesystem.stand_dir": {
        "prefix": ["filesystem.stand_dir"],
        "body": [
          "filesystem.stand_dir()"
        ],
        "description": "Returns the Stand directory path."
      },
      "filesystem.scripts_dir": {
        "prefix": ["filesystem.scripts_dir"],
        "body": [
          "filesystem.scripts_dir()"
        ],
        "description": "Returns the scripts directory path."
      },
      "filesystem.resources_dir": {
        "prefix": ["filesystem.resources_dir"],
        "body": [
          "filesystem.resources_dir()"
        ],
        "description": "Returns the resources directory path."
      },
      "filesystem.store_dir": {
        "prefix": ["filesystem.store_dir"],
        "body": [
          "filesystem.store_dir()"
        ],
        "description": "Returns the store directory path."
      },
      "filesystem.exists": {
        "prefix": ["filesystem.exists"],
        "body": [
          "filesystem.exists(${1:string path})"
        ],
        "description": "Checks if a file or directory exists."
      },
      "filesystem.is_regular_file": {
        "prefix": ["filesystem.is_regular_file"],
        "body": [
          "filesystem.is_regular_file(${1:string path})"
        ],
        "description": "Checks if a path points to a regular file."
      },
      "filesystem.is_dir": {
        "prefix": ["filesystem.is_dir"],
        "body": [
          "filesystem.is_dir(${1:string path})"
        ],
        "description": "Checks if a path points to a directory."
      },
      "filesystem.mkdir": {
        "prefix": ["filesystem.mkdir"],
        "body": [
          "filesystem.mkdir(${1:string path})"
        ],
        "description": "Creates a directory at the specified path."
      },
      "filesystem.mkdirs": {
        "prefix": ["filesystem.mkdirs"],
        "body": [
          "filesystem.mkdirs(${1:string path})"
        ],
        "description": "Creates directories along the specified path."
      },
      "filesystem.list_files": {
        "prefix": ["filesystem.list_files"],
        "body": [
          "filesystem.list_files(${1:string path})"
        ],
        "description": "Lists all files in the specified directory."
      },
      //Async HTTP Functions
      "async_http.have_access": {
        "prefix": ["async_http.have_access"],
        "body": [
          "async_http.have_access()"
        ],
        "description": "Checks if asynchronous HTTP access is available."
      },
      "async_http.init": {
        "prefix": ["async_http.init"],
        "body": [
          "async_http.init(${1:string host}, ${2:string ?path = nil}, ${3:function success_func = nil}, ${4:function fail_func = nil})"
        ],
        "description": "Initializes an asynchronous HTTP request."
      },
      "async_http.dispatch": {
        "prefix": ["async_http.dispatch"],
        "body": [
          "async_http.dispatch()"
        ],
        "description": "Completes building and dispatches the asynchronous HTTP request."
      },
      "async_http.set_post": {
        "prefix": ["async_http.set_post"],
        "body": [
          "async_http.set_post(${1:string content_type}, ${2:string payload})"
        ],
        "description": "Sets up a POST request, including content type and payload."
      },
      "async_http.add_header": {
        "prefix": ["async_http.add_header"],
        "body": [
          "async_http.add_header(${1:string key}, ${2:string value})"
        ],
        "description": "Adds a custom header to the asynchronous HTTP request."
      },
      "async_http.set_method": {
        "prefix": ["async_http.set_method"],
        "body": [
          "async_http.set_method(${1:string method})"
        ],
        "description": "Sets the HTTP request method."
      },
      "async_http.prefer_ipv6": {
        "prefix": ["async_http.prefer_ipv6"],
        "body": [
          "async_http.prefer_ipv6()"
        ],
        "description": "Prefers IPv6 for the asynchronous HTTP request."
      }
      //Memory Functions
      "memory.script_global": {
        "prefix": ["memory.script_global"],
        "body": [
          "memory.script_global(${1:int global})"
        ],
        "description": "Returns the address of the given script global."
      },
      "memory.script_local": {
        "prefix": ["memory.script_local"],
        "body": [
          "memory.script_local(${1:string|int script}, ${2:int local})"
        ],
        "description": "Returns the address of the given script local or 0 if the script was not found."
      },
      "memory.alloc": {
        "prefix": ["memory.alloc"],
        "body": [
          "memory.alloc(${1:int size = 24})"
        ],
        "description": "Allocates memory and returns a userdata with read and write operations."
      },
      "memory.alloc_int": {
        "prefix": ["memory.alloc_int"],
        "body": [
          "memory.alloc_int()"
        ],
        "description": "Allocates memory for an integer and returns a userdata with read and write operations."
      },
      "memory.scan": {
        "prefix": ["memory.scan"],
        "body": [
          "memory.scan(${1:string pattern})",
          "memory.scan(${1:string module_name}, ${2:string pattern})"
        ],
        "description": "Scans the game's memory for the given IDA-style pattern."
      },
      "memory.rip": {
        "prefix": ["memory.rip"],
        "body": [
          "memory.rip(${1:int addr})"
        ],
        "description": "Follows an offset from the instruction pointer (RIP) at the given address."
      },
      "memory.addrof": {
        "prefix": ["memory.addrof"],
        "body": [
          "memory.addrof(${1:userdata ud})"
        ],
        "description": "Returns the address of the given userdata."
      },
      "memory.read_byte": {
        "prefix": ["memory.read_byte"],
        "body": [
          "memory.read_byte(${1:int|userdata addr})"
        ],
        "description": "Reads an 8-bit integer at the given address."
      },
      "memory.read_ubyte": {
        "prefix": ["memory.read_ubyte"],
        "body": [
          "memory.read_ubyte(${1:int|userdata addr})"
        ],
        "description": "Reads an unsigned 8-bit integer at the given address."
      },
      "memory.read_short": {
        "prefix": ["memory.read_short"],
        "body": [
          "memory.read_short(${1:int|userdata addr})"
        ],
        "description": "Reads a 16-bit integer at the given address."
      },
      "memory.read_ushort": {
        "prefix": ["memory.read_ushort"],
        "body": [
          "memory.read_ushort(${1:int|userdata addr})"
        ],
        "description": "Reads an unsigned 16-bit integer at the given address."
      },
      "memory.read_int": {
        "prefix": ["memory.read_int"],
        "body": [
          "memory.read_int(${1:int|userdata addr})"
        ],
        "description": "Reads a 32-bit integer at the given address."
      },
      "memory.read_uint": {
        "prefix": ["memory.read_uint"],
        "body": [
          "memory.read_uint(${1:int|userdata addr})"
        ],
        "description": "Reads an unsigned 32-bit integer at the given address."
      },
      "memory.read_long": {
        "prefix": ["memory.read_long"],
        "body": [
          "memory.read_long(${1:int|userdata addr})"
        ],
        "description": "Reads a 64-bit integer at the given address."
      },
      "memory.read_float": {
        "prefix": ["memory.read_float"],
        "body": [
          "memory.read_float(${1:int|userdata addr})"
        ],
        "description": "Reads a floating-point number at the given address."
      },
      "memory.read_string": {
        "prefix": ["memory.read_string"],
        "body": [
          "memory.read_string(${1:int|userdata addr})"
        ],
        "description": "Reads a string at the given address."
      },
      "memory.read_vector3": {
        "prefix": ["memory.read_vector3"],
        "body": [
          "memory.read_vector3(${1:int|userdata addr})"
        ],
        "description": "Reads a Vector3 at the given address."
      },
      "memory.read_binary_string": {
        "prefix": ["memory.read_binary_string"],
        "body": [
          "memory.read_binary_string(${1:int|userdata addr}, ${2:int size})"
        ],
        "description": "Reads a binary string at the given address with the specified size."
      },
      "memory.write_byte": {
        "prefix": ["memory.write_byte"],
        "body": [
          "memory.write_byte(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes an 8-bit integer to the given address."
      },
      "memory.write_ubyte": {
        "prefix": ["memory.write_ubyte"],
        "body": [
          "memory.write_ubyte(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes an unsigned 8-bit integer to the given address."
      },
      "memory.write_short": {
        "prefix": ["memory.write_short"],
        "body": [
          "memory.write_short(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes a 16-bit integer to the given address."
      },
      "memory.write_ushort": {
        "prefix": ["memory.write_ushort"],
        "body": [
          "memory.write_ushort(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes an unsigned 16-bit integer to the given address."
      },
      "memory.write_int": {
        "prefix": ["memory.write_int"],
        "body": [
          "memory.write_int(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes a 32-bit integer to the given address."
      },
      "memory.write_uint": {
        "prefix": ["memory.write_uint"],
        "body": [
          "memory.write_uint(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes an unsigned 32-bit integer to the given address."
      },
      "memory.write_long": {
        "prefix": ["memory.write_long"],
        "body": [
          "memory.write_long(${1:int|userdata addr}, ${2:int value})"
        ],
        "description": "Writes a 64-bit integer to the given address."
      },
      "memory.write_float": {
        "prefix": ["memory.write_float"],
        "body": [
          "memory.write_float(${1:int|userdata addr}, ${2:number value})"
        ],
        "description": "Writes a floating-point number to the given address."
      },
      "memory.write_string": {
        "prefix": ["memory.write_string"],
        "body": [
          "memory.write_string(${1:int|userdata addr}, ${2:string value})"
        ],
        "description": "Writes a string to the given address."
      },
      "memory.write_vector3": {
        "prefix": ["memory.write_vector3"],
        "body": [
          "memory.write_vector3(${1:int|userdata addr}, ${2:Vector3 value})"
        ],
        "description": "Writes a Vector3 to the given address."
      },
      "memory.write_binary_string": {
        "prefix": ["memory.write_binary_string"],
        "body": [
          "memory.write_binary_string(${1:int|userdata addr}, ${2:string value})"
        ],
        "description": "Writes a binary string to the given address."
      },
      "memory.get_name_of_this_module": {
        "prefix": ["memory.get_name_of_this_module"],
        "body": [
          "memory.get_name_of_this_module()"
        ],
        "description": "Returns the name of the currently executing module."
      },
      "memory.tunable": {
        "prefix": ["memory.tunable"],
        "body": [
          "memory.tunable(${1:int|string hash})"
        ],
        "description": "Returns the address of the tunable with the given hash."
      },
      "memory.tunable_offset": {
        "prefix": ["memory.tunable_offset"],
        "body": [
          "memory.tunable_offset(${1:int|string hash})"
        ],
        "description": "Returns the offset of the tunable with the given hash."
      }
      //Profiling Functions
      "profiling.once": {
        "prefix": ["profiling.once"],
        "body": [
          "profiling.once(\"${1:string name}\", function)"
        ],
        "description": "Executes the given function and prints the time it took to your log."
      },
      "profiling.tick": {
        "prefix": ["profiling.tick"],
        "body": [
          "profiling.tick(\"${1:string name}\", function)"
        ],
        "description": "Executes the given function and shows the time it took via the info text/debug text."
      }
}   